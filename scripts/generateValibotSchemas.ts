#!/usr/bin/env tsx

// This file is generated by Claude.ai
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-nocheck

/**
 * Valibot Schema Generator for Payload CMS
 * Generates type-safe validation schemas for all collections and globals
 */

import path from "path";
import fs from "fs";
import dotenv from "dotenv";

// Load environment variables
dotenv.config();

// Suppress specific initialization errors
process.env.SUPPRESS_PAYLOAD_WARNINGS = "true";
process.env.OPENAI_API_KEY = process.env.OPENAI_API_KEY || "dummy-key-for-schema-generation";

// Path for generated schemas
const SCHEMAS_DIR = path.resolve(process.cwd(), "./src/schemas");

// Remove the schemas directory if it exists, then create it fresh
if (fs.existsSync(SCHEMAS_DIR)) {
  fs.rmSync(SCHEMAS_DIR, { recursive: true, force: true });
}
fs.mkdirSync(SCHEMAS_DIR, { recursive: true });

/**
 * Generates a Valibot schema code from a Payload field definition
 */
function generateFieldCode(field, allCollections, collection) {
  const { type, required, name, relationTo } = field;

  let schemaCode;
  let importNeeded = null;

  switch (type) {
    case "text":
    case "textarea":
    case "code":
    case "email":
    case "date":
      schemaCode = "v.string()";
      break;
    case "number":
      schemaCode = "v.number()";
      break;
    case "checkbox":
      schemaCode = "v.boolean()";
      break;
    case "select":
      if (field.hasMany) {
        schemaCode = "v.array(v.string())";
      } else {
        schemaCode = "v.string()";
      }
      break;
    case "relationship":
    case "upload":
      // Handle relationships to other collections
      // If relationTo is an array, it's a polymorphic relationship
      if (Array.isArray(relationTo)) {
        if (field.hasMany) {
          schemaCode = `v.array(v.object({
            relationTo: v.string(),
            value: v.string()
          }))`;
        } else {
          schemaCode = `v.object({
            relationTo: v.string(),
            value: v.string()
          })`;
        }
      } else if (relationTo && allCollections.includes(relationTo)) {
        // For related collections, we'll import their schema
        const relatedTypeName =
          relationTo.charAt(0).toUpperCase() +
          relationTo.slice(1).replace(/-./g, (x) => x[1].toUpperCase());
        const relatedSchemaName = `${relatedTypeName}Schema`;

        // Don't import self to avoid circular dependencies
        if (relationTo !== collection.slug) {
          importNeeded = {
            collection: relationTo,
            schemaName: relatedSchemaName,
          };
        }

        if (field.hasMany) {
          schemaCode = `v.array(${relatedSchemaName})`;
        } else {
          schemaCode = relatedSchemaName;
        }
      } else {
        // Fallback if the relation is unknown
        schemaCode = field.hasMany ? "v.array(v.string())" : "v.string()";
      }
      break;
    case "array":
      // For arrays with subfields, build a nested schema
      if (field.fields && Array.isArray(field.fields)) {
        const subFieldsCode = [];
        field.fields.forEach((subField) => {
          const { schemaCode: subFieldCode } = generateFieldCode(
            subField,
            allCollections,
            collection,
          );
          subFieldsCode.push(`    ${subField.name}: ${subFieldCode},`);
        });

        schemaCode = `v.array(v.object({\n${subFieldsCode.join("\n")}\n  }))`;
      } else {
        schemaCode = "v.array(v.any())";
      }
      break;
    case "blocks":
      // Blocks are complex, might need further customization based on your needs
      schemaCode = "v.array(v.any())";
      break;
    case "richText":
      // Rich text is complex, so we use any
      schemaCode = "v.any()";
      break;
    case "json":
      schemaCode = "v.any()"; // Could be any JSON
      break;
    case "point":
      schemaCode = "v.object({ longitude: v.number(), latitude: v.number() })";
      break;
    case "group":
      // For group fields, build a nested object schema
      if (field.fields && Array.isArray(field.fields)) {
        const subFieldsCode = [];
        field.fields.forEach((subField) => {
          const { schemaCode: subFieldCode } = generateFieldCode(
            subField,
            allCollections,
            collection,
          );
          subFieldsCode.push(`    ${subField.name}: ${subFieldCode},`);
        });

        schemaCode = `v.object({\n${subFieldsCode.join("\n")}\n  })`;
      } else {
        schemaCode = "v.object({})";
      }
      break;
    case "tabs":
      // For tabbed fields, process each tab's fields
      if (field.tabs && Array.isArray(field.tabs)) {
        const allTabFieldsCode = [];

        field.tabs.forEach((tab) => {
          if (tab.fields && Array.isArray(tab.fields)) {
            tab.fields.forEach((tabField) => {
              const { schemaCode: tabFieldCode } = generateFieldCode(
                tabField,
                allCollections,
                collection,
              );
              allTabFieldsCode.push(`    ${tabField.name}: ${tabFieldCode},`);
            });
          }
        });

        schemaCode = `v.object({\n${allTabFieldsCode.join("\n")}\n  })`;
      } else {
        schemaCode = "v.object({})";
      }
      break;
    default:
      schemaCode = "v.any()";
  }

  // Handle required fields
  if (!required && name !== "id") {
    // id is always required
    schemaCode = `v.nullish(${schemaCode})`;
  }

  return { schemaCode, importNeeded };
}

/**
 * Generates a Valibot schema code from a Payload collection config
 */
function generateSchemaCode(collection, allCollections) {
  const parts = [];
  const imports = new Set();

  parts.push("v.object({");

  // Fix: Map _id to id if there's no custom id field
  const hasIdField = collection.fields.some((field) => field.name === "id");
  if (!hasIdField) {
    // Add id field that maps to Payload's internal _id
    parts.push("  id: v.string(),");
  }

  // Process each field
  collection.fields.forEach((field) => {
    // Skip _id field as we've already handled it
    if (field.name === "_id") return;

    const { schemaCode, importNeeded } = generateFieldCode(field, allCollections, collection);

    if (importNeeded) {
      imports.add(importNeeded);
    }

    parts.push(`  ${field.name}: ${schemaCode},`);
  });

  parts.push("})");

  return {
    schemaCode: parts.join("\n"),
    imports: Array.from(imports),
  };
}

/**
 * Load the Payload config and generate schemas
 */
async function run() {
  try {
    console.log("Loading Payload config...");

    // Import the config with fallbacks
    let config;
    try {
      // Try first with the path alias if it works in your setup
      const configModule = await import("@payload-config");
      config = configModule.default;
    } catch (_) {
      // Fallback to direct path if alias doesn't work
      console.log("Fallback to direct import...");
      const configModule = await import("./src/payload.config");
      config = configModule.default;
    }

    // Handle config that might be a promise
    if (config instanceof Promise) {
      config = await config;
    }

    console.log("Config loaded, generating schemas...");

    if (!config || !config.collections) {
      throw new Error("Invalid Payload configuration: collections not found");
    }

    const collections = config.collections.filter(({ slug }) => !slug.startsWith("payload-"));

    // Get all collection slugs for relationship handling
    const collectionSlugs = collections.map((collection) => collection.slug);

    console.log("collectionSlugs", collectionSlugs);

    // Generate schemas for collections
    console.log("\nGenerating schemas for collections...");
    for (const collection of collections) {
      console.log(`- Processing ${collection.slug}...`);

      // Determine schema name
      const typeName = (
        collection.slug.charAt(0).toUpperCase() +
        collection.slug.slice(1).replace(/-./g, (x) => x[1].toUpperCase())
      ).replace(/s$/, ""); // Remove plural "s" if present

      const schemaName = `${typeName}Schema`;

      // Generate the schema code
      const { schemaCode, imports } = generateSchemaCode(collection, collectionSlugs);

      // Generate imports for related schemas
      const importStatements = imports
        .map((imp) => {
          const relatedTypeName =
            imp.collection.charAt(0).toUpperCase() +
            imp.collection.slice(1).replace(/-./g, (x) => x[1].toUpperCase());
          return `import { ${imp.schemaName} } from "./${relatedTypeName}Schema";`;
        })
        .join("\n");

      // Generate output content
      const outputContent = `/**
 * THIS FILE IS AUTO-GENERATED. DO NOT MODIFY.
 */

import * as v from "valibot";
${imports.length > 0 ? importStatements + "\n" : ""}
export const ${schemaName} = ${schemaCode};

export type ${typeName} = v.InferOutput<typeof ${schemaName}>;

export function validate${typeName}(data: unknown): ${typeName} {
  return v.parse(${schemaName}, data);
}

export function validate${typeName}s(data: unknown): { docs: ${typeName}[] } {
  return v.parse(v.object({ docs: v.array(${schemaName}) }), data);
}
`;

      // Save the output
      const outputPath = path.join(SCHEMAS_DIR, `${schemaName}.ts`);
      fs.writeFileSync(outputPath, outputContent);

      console.log(`  Schema saved to: ${outputPath}`);
    }

    // Generate schemas for globals if they exist
    if (config.globals && Array.isArray(config.globals)) {
      console.log("\nGenerating schemas for globals...");

      for (const global of config.globals) {
        console.log(`- Processing ${global.slug}...`);

        // Determine schema name
        const typeName =
          global.slug.charAt(0).toUpperCase() +
          global.slug
            .slice(1)
            .replace(/-./g, (x) => x[1].toUpperCase())
            .replace(/s$/, ""); // Remove plural "s" if present

        const schemaName = `Global${typeName}Schema`;

        // Generate the schema code - treat globals similar to collections
        const { schemaCode, imports } = generateSchemaCode(
          {
            ...global,
            // Globals don't have implicit fields like collections do
          },
          collectionSlugs,
        );

        // Generate imports for related schemas
        const importStatements = imports
          .map((imp) => {
            const relatedTypeName =
              imp.collection.charAt(0).toUpperCase() +
              imp.collection.slice(1).replace(/-./g, (x) => x[1].toUpperCase());
            return `import { ${imp.schemaName} } from "./${relatedTypeName}Schema";`;
          })
          .join("\n");

        // Generate output content
        const outputContent = `/**
 * THIS FILE IS AUTO-GENERATED. DO NOT MODIFY.
 */

import * as v from "valibot";
${imports.length > 0 ? importStatements + "\n" : ""}
export const Global${typeName}Schema = ${schemaCode};

export type Global${typeName} = v.InferOutput<typeof Global${typeName}Schema>;

export function validateGlobal${typeName}(data: unknown): Global${typeName} {
  return v.parse(Global${typeName}Schema, data);
}
`;

        // Save the output
        const outputPath = path.join(SCHEMAS_DIR, `${schemaName}.ts`);
        fs.writeFileSync(outputPath, outputContent);

        console.log(`  Schema saved to: ${outputPath}`);
      }
    }

    console.log("\nAll schemas generated successfully!");
  } catch (error) {
    console.error("Error generating schemas:", error);
    console.error(error.stack);
    process.exit(1);
  }
}

run();
